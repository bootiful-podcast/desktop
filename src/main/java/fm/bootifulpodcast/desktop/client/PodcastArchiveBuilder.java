package fm.bootifulpodcast.desktop.client;

import lombok.SneakyThrows;
import lombok.extern.log4j.Log4j2;
import org.springframework.util.Assert;
import org.springframework.util.FileCopyUtils;
import org.springframework.util.FileSystemUtils;
import org.springframework.util.StreamUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Log4j2
public class PodcastArchiveBuilder {

	/**
	 * @param zipFile The file to which the resulting archive should be written
	 * @param uid the UID of the manifest, generated by the client for correllation of the
	 * request through the system.
	 * @param title the title for the podcast
	 * @param description the description for the podcast
	 * @param interview the {@code .mp3} for the interview
	 * @param intro the {@code .mp3} for the introduction
	 * @param photo the {@code .mp3} for the interviewee photo
	 * @return the file to which the resulting archive was written.
	 */
	@SneakyThrows
	public File createArchive(File zipFile, String uid, String title, String description, File intro, File interview,
			File photo) {

		var staging = new File(zipFile.getParent(), "staging-" + UUID.randomUUID());
		Assert.isTrue(staging.exists() || staging.mkdirs(), "the staging directory could not be created");

		var srcFiles = new ArrayList<File>();
		srcFiles.add(interview);
		srcFiles.add(intro);
		srcFiles.add(photo);

		var xmlFile = new File(staging, "manifest.xml");
		try (var xmlOutputStream = new BufferedWriter(new FileWriter(xmlFile))) {
			var xml = buildXmlManifestForPackage(title, description, uid, intro, interview, photo);
			FileCopyUtils.copy(xml, xmlOutputStream);
			srcFiles.add(xmlFile);
		}

		try (var outputStream = new BufferedOutputStream(new FileOutputStream(zipFile));
				var zipOutputStream = new ZipOutputStream(outputStream)) {
			for (var fileToZip : srcFiles) {
				try (var inputStream = new BufferedInputStream(new FileInputStream(fileToZip))) {
					var zipEntry = new ZipEntry(fileToZip.getName());
					zipOutputStream.putNextEntry(zipEntry);
					StreamUtils.copy(inputStream, zipOutputStream);
				}
			}
		}
		Assert.isTrue(FileSystemUtils.deleteRecursively(staging),
				"the staging directory " + staging.getAbsolutePath() + " couldn't be deleted");

		return zipFile;
	}

	@SneakyThrows
	private static String buildXmlManifestForPackage(String title, String description, String uid, File intro,
			File interview, File photo) {

		var docFactory = DocumentBuilderFactory.newInstance();
		var docBuilder = docFactory.newDocumentBuilder();

		var doc = docBuilder.newDocument();
		var rootElement = doc.createElement("podcast");
		rootElement.setAttribute("uid", uid);
		rootElement.setAttribute("title", title);
		doc.appendChild(rootElement);

		/*
		 * <podcast uid = "uid" title = "A Title"> <interview src = "/some.mp3" />
		 * <introduction src = "/some.mp3" /> <photo src = "/some/file.jpg"/>
		 * <description> CDATA text </description> </podcast>
		 */
		var interviewElement = createElementWithAttributes(doc, "interview", Map.of("src", interview.getName()));
		var introductionElement = createElementWithAttributes(doc, "introduction", Map.of("src", intro.getName()));
		var photoElement = createElementWithAttributes(doc, "photo", Map.of("src", photo.getName()));

		var descriptionElement = doc.createElement("description");
		descriptionElement.appendChild(doc.createCDATASection(description));

		Arrays.asList(interviewElement, introductionElement, photoElement, descriptionElement)
				.forEach(rootElement::appendChild);

		var transformerFactory = TransformerFactory.newInstance();

		var transformer = transformerFactory.newTransformer();
		transformer.setOutputProperty(OutputKeys.INDENT, "yes");
		transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");

		var source = new DOMSource(doc);
		var stringWriter = new StringWriter();
		var result = new StreamResult(stringWriter);
		transformer.transform(source, result);
		return stringWriter.toString();
	}

	private static Element createElementWithAttributes(Document doc, String elementName, Map<String, String> attrs) {
		var element = doc.createElement(elementName);
		attrs.forEach(element::setAttribute);
		return element;
	}

}
